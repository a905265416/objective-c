# 分类（Category）

OC中特有的语法，一个指向分类的结构体的指针。原则上只能增加方法，不能增加成员（实例）变量。**一般放在.h文件中**

```objective-c
Category
Category 是表示一个指向分类的结构体的指针，其定义如下：
typedef struct objc_category *Category;
struct objc_category {
  char *category_name                          OBJC2_UNAVAILABLE; // 分类名
  char *class_name                             OBJC2_UNAVAILABLE; // 分类所属的类名
  struct objc_method_list *instance_methods    OBJC2_UNAVAILABLE; // 实例方法列表
  struct objc_method_list *class_methods       OBJC2_UNAVAILABLE; // 类方法列表
  struct objc_protocol_list *protocols         OBJC2_UNAVAILABLE; // 分类所实现的协议列表
}
```

一个分类可以将方法的实现分解进一系列分离的文件。可以将一组相关的方法放进一个分类。

若分类声明了与类中原有方法同名的函数，则分类中的方法会被调用。因此分类不仅可以增加类的方法，也可以代替原用的方法。这个特性可以用于修正原油代码中的错误，更可以从根本上改变程序中原有类的行为。若两个分类中的方法同名，则被调用的方法是不可预测的。

同名方法调用优先级为：分类>本类>父类

**分类不能添加属性，只能添加方法**

实质原因：在类中用@property声明属性，编译器会自动帮我们生成**成员变量**和**setter/getter**，但分类的指针结构体中，根本没有属性列表。所以在分类中用@property声明属性，既无法生成**成员变量**也无法生成**setter/getter**。

结论：可以用@property声明属性，编译运行能通过，只要不是用就不会崩溃。

# 扩展（Extension）

1、类别中原则上只能增加方法（能添加属性的原因只是通过runtime解决无setter/getter的问题而已）；

2、类拓展不仅可以增加方法，还可以增加实例变量（或者属性），只是该实例变量默认是@private类型的，使用范围只能在自身类，而不是子类或其他地方；

3、类拓展中声明的方法没被实现，编译器会报警，但是类别中的方法没被实现编译器是不会有任何报警的。。这是因为类扩展是在编译阶段被添加到类中，而分类是在运行时添加到类中。

4、类扩展不能像类别那样拥有独立的实现部分，类扩展所声明的方法必须依托对应类的实现部分类实现。

5、定义在.m文件中的类扩展方法为私有的，定义在.h文件中的类扩展方法为公有的。类扩展是在.m文件中声明私有方法的非常好的方式。

## 类别与类扩展的区别：

①类别中原则上只能增加方法（能添加属性的的原因只是通过`runtime`解决无`setter/getter`的问题而已）；
 ②类扩展不仅可以增加方法，还可以增加实例变量（或者属性），只是该实例变量默认是@private类型的（
 用范围只能在自身类，而不是子类或其他地方）；
 ③类扩展中声明的方法没被实现，编译器会报警，但是类别中的方法没被实现编译器是不会有任何警告的。这是因为**类扩展是在编译阶段被添加到类中，而类别是在运行时添加到类中**。
 ④类扩展不能像类别那样拥有独立的实现部分（@implementation部分），也就是说，类扩展所声明的方法必须依托对应类的实现部分来实现。
 ⑤定义在 .m 文件中的类扩展方法为私有的，定义在 .h 文件（头文件）中的类扩展方法为公有的。类扩展是在 .m 文件中声明私有方法的非常好的方式。